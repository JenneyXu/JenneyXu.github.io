---
layout: post
title:  JS基础一 -- this、原型、原型链
date:   2019-05-30 00:00:00 +0800
categories: JavaScript
tag: js基础
---

* content
{:toc}


#### <font color="#65A5EA" size="3">1. 重新认识 this</font>			{#say-goodbyte}

“this是指函数本身”，“this指向函数的作用域“--这中对this的理解不完全正确。  
**那么，this 到底是什么？**  
&emsp;&emsp;this 的使之是指针，是在函数被调用时发生的绑定，它的指向什么完全取决于函数在哪里被调用。当一个函数被调用时，会创建一个活动记录（又称为执行上下文），这个记录会包含函数在哪里被调用，调用方式，传入的参数等信息。this 就是这个记录的一个属性，会在函数的执行过程中用到。

**绑定规则：**
* 默认绑定 	this 默认绑定到全局对象或undefinded上。
* 隐式绑定  this隐式地“传递”一个对象的引用。
&emsp;&emsp;*必须在一个对象内部包含一个指向函数的引用，并通过这个属性间接引用函数。注：对象属性引用链只有最后一层绑定才有效。存在回调函数丢失 this 绑定的情况，丢失this绑定后，this默认指向全局。*  
* 显示绑定 	通过call，apply ，bind 实现显示绑定。
* new 绑定  
&emsp;&emsp; 确切滴说，在js中 并不存在所谓的“构造函数”，而是对于函数的“构造调用”。  
&emsp;&emsp; new 的过程：
&emsp;&emsp;（1）创建一个全新的对象；  
&emsp;&emsp;（2）这个新对象会被执行 [[Prototype]] 连接；  
&emsp;&emsp;（3）这个对象会绑定到函数调用的this，绑定到实例上；  
&emsp;&emsp;（4）如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。  
>function create() {  
>>let obj = {} //创建一个新对象  
>>let Con = [].shift.call(arguments) //获取构造函数    
>>obj.__proto__ = Con.prototype //设置对象原型  
>>let result = Con.apply(obj, arguments) //绑定this  
>>return result instanceof Object ? result : obj //返回新对象
>}  
* 箭头函数
箭头函数的this指向定义函数时所在的作用域，而且这个this是不能被 call\apply\bind 更改的。虽然这么写不会报错 但是this指向不会变。 其实，箭头函数，在涉及this绑定的问题和普通函数完全不一致。取而代之的是用当前词法作用域覆盖了this本来的值。  
apply

**<font color="#65A5EA" size="2">几种改变 this 指向的方式优先级：new绑定 > 显示绑定 > 隐式绑定 > 默认绑定。</font>**  
 
#### <font color="#65A5EA" size="3">2. 原型和原型链</font>			{#say-goodbyte} 
&emsp;&emsp;对于 obj 来说(每个obj都有 __proto__ 属性)，可以通过 __proto__ 找到一个原型对象。  
&emsp;&emsp;**但是，为什么有的基本类型也可以调用方法呢？比如 123.length**  
&emsp;&emsp;那是因为除了 null、undefined 以外的基本类型都有与之对应的特殊的引用类型——包装类型。当代码被解释执行时，底层会将基本类型转换成引用类型，这样基本类型就可以调用与之相对应的引用类型的属性和方法。

**（1）typeof 返回数据类型，常用于判断除null之外的基本类型**    
对于除了 null 之外的基本类型，可以通过 typeof 获得正确的数据类型。 (typeof null //Object)    
对于除了function 之外的对象，typeof 都会返回 object 。 (typeof Function//function) 

**（2）instanceOf 返回boolean，用于判断一个实例是否属于某种类型，会追溯原型链**  
除了Object 和 Function 之外，instanceof 自己等于false：    
>Object instanceof Object       //true  
>Function instanceof Function  //true  
>Function instanceof Object   //true  
>Number instanceof Number    //false  
>String instanceof String   //false  
>var num1 = new Number();  num1 instanceOf Number  //true   
>var num2 = '123';  num2 instanceOf Number  //false 

**(3)Object.prototype.toString.call(xx) 用于获取XX正确的数据类型，返回[Object Type] 的字符串**  
&emsp;&emsp;因为所有类型都是 object 的实例，toString 方法可以读取对象的内部属性[[class]]。  
&emsp;&emsp;为什么不直接使用 toString 呢？因为 toString 为 Object 的原型方法，而 Array、function、Date 等类型作为Object的实例，都重写了 toString 方法。  

**（4）constructor 是 object 对象的一个属性，用于判断 object 类型的数据**
>var arr = [1,2,3];  
>arr.constructor == Array    //true   

**（5）isArray es6提供的新方法，返回boolen，用于判断数组类型**  
>var arr = [1,2,3];  
>Array.isArray(arr)    //true  

#### <font color="#65A5EA" size="3">4. 数据类型转换</font>			{#say-goodbyte}  
* **在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。**  
* 另规定，console.log(null==null && undefined==undefined && null==undefined)  
* **对象在转换基本类型时，会优先将值转换为原始值（toPrimitive优先级最高），再转换为数字（valueOf），最后转换为字符串（toString）。** 

